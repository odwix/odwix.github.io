<html>
    <body onload="init();">     

    <script>
        let g_areasData = null;
        var g_menuImage = null;
        var g_menuBuilderCanvas = null;
        var g_offscreenCanvas = null;
        let g_mouseX = 0;
        let g_mouseY = 0;
        let g_drawSelectionRectMode = false;
        let g_selectionRectOrgX = 0;
        let g_selectionRectOrgY = 0;
        let g_drawMarkedArea = false;

        let g_originalImageWidth = 0;
        let g_originalImageHeight = 0;

        const LabelFillStyle = "rgba(255, 255, 0, 0.8";
        const LabelBorderStyle = "#000000";

        let g_markedArea = {x:0, y:0, w:0, h:0};

        let g_wordsInfo = [];

        let g_screenPartitions = []; //array of rectangles

        let g_config = {
            drawFullStats: false,
            drawCursorLabels: false,
            drawPartitions: false,
            drawUserSelection: false,
            drawAllAreas: false,
        }

        window.onmessage = (event) => {
                let eventData = event.data;
                if(eventData.msg === 'setConfig') {
                    g_config = eventData.config;
                    updateGraphics();
                } else if(eventData.msg === 'setImage') {   
                    g_menuImage = null;
                    updateGraphics();   

                    window.parent.postMessage({msg:'imageUnloaded'}, '*');  
                                
                    g_menuImage = new Image(); 
                    g_menuImage.src = eventData.src
                    g_menuImage.onload = () => {
                        g_menuBuilderCanvas.width = g_menuImage.width;
                        g_menuBuilderCanvas.height = g_menuImage.height;
                        if(g_menuImage.height > 1800) {    
                            let prop = g_menuImage.width /  document.getElementById('main').getBoundingClientRect().width;                   
                            g_menuBuilderCanvas.style.height = `${g_menuImage.height/prop}px`;
                        }
                        initScreenPartitions();
                        updateGraphics();
                        window.parent.postMessage({msg:'imageLoaded'}, '*');
                    }                  
                } else if(eventData.msg === 'markArea') {
                    g_markedArea = eventData.markArea;
                    g_drawMarkedArea = true;
                    updateGraphics();
                } else if(eventData.msg === 'clearMarkArea') {
                    g_markedArea = {x:0, y:0, w:0, h:0};
                    g_drawMarkedArea = false;
                    updateGraphics();
                } else if(eventData.msg === 'setAllAreas') {
                    g_areasData = eventData.areasData;     
                    updateGraphics();      
                } else if(eventData.msg === 'clearAllAreas') {
                    g_areasData = null;
                    g_wordsInfo = [];
                    updateGraphics();
                } else if(eventData.msg === 'setWordsInfo') {
                    g_wordsInfo = eventData.wordsInfo;
                    //console.log(JSON.stringify(g_wordsInfo));
                  
                    updateGraphics();
                }
        }

        function init() {
            g_menuBuilderCanvas = document.getElementById('menuBuilder');
            g_menuBuilderCanvas.onmousemove = ((event) => {
                    if(g_areasData !== null && g_menuImage !== null) {
                    let rc = g_menuBuilderCanvas.getBoundingClientRect();
                    
                    let rx = g_menuImage.width / rc.right;
                    let ry = g_menuImage.height / rc.height;
                    g_mouseX = (event.clientX - rc.left) * rx;
                    g_mouseY = (event.clientY - rc.top) * ry;  
                    //console.log(`ry:${ry} rcTop:${rc.top} mouseY:${g_mouseY} scrollTop:${document.getElementById('main').scrollTop} height:${g_menuBuilderCanvas.style.height}`)
                    
                    let parIdx = partitionIndexFromMousePos();
                    //console.log(`screen partition id:${parIdx}`);              
                    updateGraphics();
                }
            });

            function notifySelectedArea(command, event) {
                if(g_areasData !== null && g_menuImage !== null) {                                   
                    let i = areaIndexFromMousePos();
                    let areadDataValid = i > -1;   
                    let userSelectedRectValid = userMarkingSelection();  
                    const [rcLeft, rcTop, rcRight, rcBottom] = getSelectedWordsBoundingRect();                       
                    let msg = {
                        msg: command,
                        areaDataValid: areadDataValid,
                        areaData: g_areasData[i],
                        userSelectedRectValid: userSelectedRectValid,
                        userSelectedRect: {
                            x: userSelectedRectValid ? parseInt(rcLeft) : -1,
                            y: userSelectedRectValid ? parseInt(rcTop) : -1,
                            w: userSelectedRectValid ? parseInt(rcRight - rcLeft) : -1,
                            h: userSelectedRectValid ? parseInt(rcBottom - rcTop) : -1,
                        }
                    }
                    //console.log(`mouseup selected id: ${msg.areaData.id}`);
                    window.parent.postMessage(msg, "*");                    
                }
            }

            g_menuBuilderCanvas.onmouseup = ((event) => {
                notifySelectedArea('areaSelected', event);
            });

            g_menuBuilderCanvas.ondblclick = ((event) => {
                notifySelectedArea('areaSelected-dblclick', event);
                console.log('areaSelected-dblclick');
            });

            g_menuBuilderCanvas.onpointerdown = (e) => {
                g_drawSelectionRectMode = true;
                g_selectionRectOrgX = g_mouseX;
                g_selectionRectOrgY = g_mouseY;
                g_menuBuilderCanvas.onpointermove = (e) => {
                    updateGraphics(); 
                };
                g_menuBuilderCanvas.setPointerCapture(e.pointerId);
                updateGraphics();
            }

            g_menuBuilderCanvas.onpointerup = (e) => {
                g_drawSelectionRectMode = false;
                g_menuBuilderCanvas.onpointermove = null;
                g_menuBuilderCanvas.releasePointerCapture(e.pointerId);
                updateGraphics();
            }

            // g_menuBuilderCanvas.width = 1500;

            g_offscreenCanvas = document.createElement('canvas');
            g_offscreenCanvas.getContext('2d').translate(-.5, -.5);
           
            updateGraphics();
        }

        function userMarkingSelection() {
            return g_config.drawUserSelection && Math.abs(g_mouseX- g_selectionRectOrgX) > 10 && Math.abs(g_mouseY - g_selectionRectOrgY) > 3;
        }

        function areaIndexFromMousePos() {
            if(g_areasData !== null) {
                for(let i=0; i<g_areasData.length; i++) {
                    if(
                        g_mouseX > g_areasData[i].x &&
                        g_mouseX < g_areasData[i].x + g_areasData[i].w &&
                        g_mouseY > g_areasData[i].y &&
                        g_mouseY < g_areasData[i].y + g_areasData[i].h
                    ) {
                        return i;
                    }
                }
            }
            return -1;
        }

        function ptInRect(ptX, ptY, rcX, rcY, rceX, rceY) {
            return (ptX >= rcX && ptX <= rceX) && (ptY >= rcY && ptY <= rceY);                
        }

        function rectIntersect(r1_x, r1_y, r1_cx, r1_cy, r2_x, r2_y, r2_cx, r2_cy) {
            let intersection = !(
                (r1_x > r2_cx)   ||
                (r1_cx < r2_x)   ||
                (r1_y > r2_cy)   ||
                (r1_cy < r2_y)
                );
            return intersection;
        }

        function wordsInfoIndicesFromMousePos() {
            //TODO: Implement an optimized search using the partitions...
            let res = [];
            if(g_wordsInfo !== null) {
                for(let i=0; i<g_wordsInfo.length; i++) {
                    if(
                        g_mouseX > g_wordsInfo[i].poly.x &&
                        g_mouseX < g_wordsInfo[i].poly.x + g_wordsInfo[i].poly.w &&
                        g_mouseY > g_wordsInfo[i].poly.y &&
                        g_mouseY < g_wordsInfo[i].poly.y + g_wordsInfo[i].poly.h
                    ) {
                        res.push(i);
                    }
                }
            }
            return res;        
        }

        function wordsInfoIndicesFromBoundingRect(x, y, w, h) {
            let res = [];
            let cx = Math.min(x, x+w);
            let cy = Math.min(y, y+h);
            let ex = Math.max(x, x+w);
            let ey = Math.max(y, y+h);
            if(g_wordsInfo !== null) {
                for(let i=0; i<g_wordsInfo.length; i++) {  
                    if(rectIntersect (
                        cx, cy,
                        ex, ey,
                        g_wordsInfo[i].poly.x, g_wordsInfo[i].poly.y,
                        g_wordsInfo[i].poly.x+g_wordsInfo[i].poly.w, g_wordsInfo[i].poly.y+g_wordsInfo[i].poly.h)
                        ) {
                        res.push(i);
                    }
                }
            }
            return res;
        }

        function getSelectedWordsBoundingRect() {
            let wi = wordsInfoIndicesFromBoundingRect(g_selectionRectOrgX, g_selectionRectOrgY, g_mouseX - g_selectionRectOrgX , g_mouseY - g_selectionRectOrgY);
            let lastLeft = Number.MAX_SAFE_INTEGER;
            let lastRight = Number.MIN_SAFE_INTEGER;
            let lastTop = Number.MAX_SAFE_INTEGER;
            let lastBottom = Number.MIN_SAFE_INTEGER;
            for(let i=0; i<wi.length; i++) {
                let idx = wi[i];
                let wordInfoPoly = g_wordsInfo[idx].poly;
                if(wordInfoPoly.x < lastLeft) lastLeft = wordInfoPoly.x;
                if(wordInfoPoly.x + wordInfoPoly.w > lastRight) lastRight = wordInfoPoly.x + wordInfoPoly.w;
                if(wordInfoPoly.y < lastTop) lastTop = wordInfoPoly.y;
                if(wordInfoPoly.y + wordInfoPoly.h > lastBottom) lastBottom = wordInfoPoly.y + wordInfoPoly.h;
            }
            
            if(wi.length < 1) {
                lastLeft = 0;
                lastRight = 0;
                lastTop = 0;
                lastBottom = 0;
            }

            //console.log(`${lastLeft},${lastTop},${lastRight},${lastBottom}`);

            return [lastLeft, lastTop, lastRight, lastBottom];
        }

        function initScreenPartitions() {
            g_screenPartitions = [];
            let partWidth = 500;
            let partHeight = 500;

            let parCountX = g_menuImage.width / partWidth + 1;
            let parCountY = g_menuImage.height / partHeight + 1;

            partWidth = g_menuImage.width / parCountX;
            partHeight = g_menuImage.height / parCountY;


            for(let j=0; j<parCountY; j++) {
                for(let i=0; i<parCountX; i++) {
                    let x = i*partWidth;
                    let y = j*partHeight;
                    g_screenPartitions.push({x, y, w:partWidth, h:partHeight});
                }
            }
        }

        function partitionIndexFromMousePos() {
            for(let i=0; i<g_screenPartitions.length; i++) {
                if(
                    g_mouseX > g_screenPartitions[i].x &&
                    g_mouseX < g_screenPartitions[i].x + g_screenPartitions[i].w &&
                    g_mouseY > g_screenPartitions[i].y &&
                    g_mouseY < g_screenPartitions[i].y + g_screenPartitions[i].h
                    ) {
                        return i;
                    }
            }
        }




        /// Drawing functionality

        function drawMenuImage(canvas) {
            if(g_menuImage !== null) {
                let ctx = canvas.getContext('2d');
                ctx.drawImage(g_menuImage, 0, 0);
            }
        }

        function drawLabel(canvas, text, x, y, width, height, txtFill, bgStroke, bgFill) {
            let ctx = canvas.getContext('2d');
            let xSpacing = 5;
            let ySpacing = (height - 12) / 2;

            ctx.save();
            ctx.textAlign = 'start';
            ctx.font = 'small-caption';
            let txtWidth = ctx.measureText(text).width;

            width = txtWidth > width ? txtWidth + xSpacing * 2 : width;
            if (width + x > canvas.width) {
                x = canvas.width - width;
            }            

            ctx.beginPath();
            ctx.fillStyle = bgFill;
            ctx.strokeStyle = bgStroke;
            ctx.fillRect(x, y, width, height);
            ctx.strokeRect(x, y, width, height);

            ctx.beginPath();
            ctx.fillStyle = txtFill;
            ctx.textAlign = 'start top';

            ctx.fillText(text, x + xSpacing, y + height - ySpacing);
            ctx.stroke();
            ctx.restore();
        }

        function drawFrame(canvas, x, y, width, height, bgStroke, bgFill) {
            let ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.fillStyle = bgFill;
            ctx.strokeStyle = bgStroke;
            ctx.fillRect(x, y, width, height);
            ctx.strokeRect(x, y, width, height);
            ctx.restore();
        }

        function drawText(canvas, text, x, y) {
            let fillStyle = "rgba(255, 0, 0, " + 0 + ")";
            let strokeStyle = "rgba(0, 0, 0, " + 1.0 + ")";
            drawLabel(canvas, text, x, y, 0, 0, strokeStyle, "#00000000", fillStyle); 
        }        

        function updateGraphics() {
            g_offscreenCanvas.width = g_menuBuilderCanvas.width;
            g_offscreenCanvas.height = g_menuBuilderCanvas.height;
            let ctx = g_offscreenCanvas.getContext("2d");
            ctx.clearRect(0, 0, g_offscreenCanvas.width, g_offscreenCanvas.height);
            ctx.translate(.5, .5); //required to make the lines sharp

            //draw background:
            ctx.save();
            ctx.lineWidth = 1;
            ctx.fillStyle = "#e0e0e0";
            ctx.fillRect(0, 0, g_offscreenCanvas.width, g_offscreenCanvas.height);
            ctx.restore();

            ctx.save();
            drawMenuImage(g_offscreenCanvas);
            ctx.restore();

            //draw partitions:
            let  drawPartitions = g_config.drawPartitions;
            if(drawPartitions) {
                ctx.save();
                for (let i = 0; i < g_screenPartitions.length; i++) {
                    drawFrame(g_offscreenCanvas, g_screenPartitions[i].x+1, g_screenPartitions[i].y+1, g_screenPartitions[i].w-2, g_screenPartitions[i].h-2, "#0000ffff", "#00000000")            
                }
                ctx.restore();
            }

            //draw label:
            let text = "Menu Renderer v0.1";
            // drawText(g_offscreenCanvas, text, 10, 10); 

            let rc = g_menuBuilderCanvas.getBoundingClientRect();
            //console.log(`boundigRect:${JSON.stringify(rc)}`);
            let rx = (g_menuImage !== null) ? g_menuImage.width / rc.right : 1;
            let ry = (g_menuImage !== null) ? g_menuImage.height / rc.bottom : 1;
            //console.log(`menuImageW:${(g_menuImage !== null) ? g_menuImage.width : -1} menuImageH:${(g_menuImage !== null) ? g_menuImage.height : -1} ratio: rx:${rx} ry:${ry} mouseX:${g_mouseX} mouseY:${g_mouseY}`);

            if(g_drawMarkedArea) {
                ctx.save();
                //ctx.globalCompositeOperation = 'difference';
                drawFrame(g_offscreenCanvas, g_markedArea.x, g_markedArea.y, g_markedArea.w, g_markedArea.h, "#00ff003c","#00ff003c");
                ctx.lineWidth = 2;
                ctx.setLineDash([2,2]);
                drawFrame(g_offscreenCanvas, g_markedArea.x, g_markedArea.y, g_markedArea.w, g_markedArea.h, "#003c00ff","#00000000");
                ctx.restore();
            }

            
            if(g_areasData !== null) {
                ctx.save();
                if(g_config.drawAllAreas) {
                    for(let i=0; i<g_areasData.length; i++) {
                        ctx.lineWidth = 2;
                        ctx.setLineDash([2,2]);
                        if(!(
                            g_areasData[i].x === g_markedArea.x &&
                            g_areasData[i].y ===g_markedArea.y &&
                            g_areasData[i].w === g_markedArea.w &&
                            g_areasData[i].h === g_markedArea.h
                            )) {
                                drawFrame(g_offscreenCanvas, g_areasData[i].x, g_areasData[i].y, g_areasData[i].w, g_areasData[i].h, "#0000ffff","#0000ff1a");
                            }
                    }
                } 

                let i = areaIndexFromMousePos();
                if(i > -1) {                    
                    //ctx.globalCompositeOperation = 'difference';                        
                    drawFrame(g_offscreenCanvas, g_areasData[i].x, g_areasData[i].y, g_areasData[i].w, g_areasData[i].h, "#0000ff3c","#0000ff3c");                                       
                }
                
                ctx.restore(); 
            }


            let drawFullStats = g_config.drawFullStats;
            ctx.save();
            let words = [];
            let wi = g_drawSelectionRectMode ? g_config.drawUserSelection && wordsInfoIndicesFromBoundingRect(g_selectionRectOrgX, g_selectionRectOrgY, g_mouseX - g_selectionRectOrgX , g_mouseY - g_selectionRectOrgY) : wordsInfoIndicesFromMousePos();
            for(let i=0; i<wi.length; i++) {
                let idx = wi[i];
                let wordInfoPoly = g_wordsInfo[idx].poly;
                drawFrame(g_offscreenCanvas, wordInfoPoly.x, wordInfoPoly.y, wordInfoPoly.w, wordInfoPoly.h, "#ffff007e","#ffff007e");
                let w = drawFullStats ? `${g_wordsInfo[idx].word}(x:${wordInfoPoly.x} y:${wordInfoPoly.y} w:${wordInfoPoly.w} h:${wordInfoPoly.h})` : `${g_wordsInfo[idx].word}`;
                words.push(w);
                //console.log(`wordsInfoPoly[${idx}]: ${JSON.stringify(wordInfoPoly)}`);
            }
            
            let drawCursorLabels = (g_config.drawCursorLabels || g_drawSelectionRectMode) && (g_mouseX > 0  && g_mouseY > 0);
            if(drawCursorLabels) {
                if(words.length > 0 && !g_drawSelectionRectMode) {
                    drawLabel(g_offscreenCanvas, `(${parseInt(g_mouseX)},${parseInt(g_mouseY)}) ${words.join(" ")}`, g_mouseX, g_mouseY-22, 0, 22, "#000000ff", "#000000ff", "#ffffffff");
                } else if(g_drawSelectionRectMode) {
                    if(userMarkingSelection()) {
                        let ttX = Math.min(g_mouseX, g_selectionRectOrgX);
                        let ttY = Math.min(g_mouseY, g_selectionRectOrgY);
                        const [rcLeft, rcTop, rcRight, rcBottom] = getSelectedWordsBoundingRect();
                        if(g_config.drawCursorLabels) {
                            drawLabel(g_offscreenCanvas, `(${(rcLeft)}, ${(rcTop)}) - (${(rcRight)}, ${(rcBottom)})`, ttX, ttY-22, 0, 22, "#000000ff", "#000000ff", "#ffffffff");
                        }
                        ctx.lineWidth = 2;
                        drawFrame(g_offscreenCanvas, rcLeft, rcTop, rcRight-rcLeft , rcBottom-rcTop, "#7e7e00ff", "#00000000");
                        ctx.setLineDash([5,5]);
                        drawFrame(g_offscreenCanvas, rcLeft, rcTop, rcRight-rcLeft , rcBottom-rcTop, "#000000ff", "#00000000");
                        
                        //drawLabel(g_offscreenCanvas, `(x:${parseInt(g_selectionRectOrgX)}, y:${parseInt(g_selectionRectOrgY)})(w:${Math.abs(parseInt(g_mouseX - g_selectionRectOrgX))}, h:${Math.abs(parseInt(g_mouseY - g_selectionRectOrgY))})`, ttX, ttY-22, 0, 22, "#000000ff", "#000000ff", "#ffffffff");
                    }
                } else {
                    drawLabel(g_offscreenCanvas, `(${parseInt(g_mouseX)},${parseInt(g_mouseY)})`, g_mouseX, g_mouseY-22, 0, 22, "#000000ff", "#000000ff", "#ffffffff");
                }
            }
            ctx.restore();

            ctx.save();
            if(g_drawSelectionRectMode) {
                ctx.lineWidth = 2;
                ctx.setLineDash([5,5]);
                drawFrame(g_offscreenCanvas, g_selectionRectOrgX, g_selectionRectOrgY, g_mouseX- g_selectionRectOrgX , g_mouseY - g_selectionRectOrgY, "#000000ff", "#00000000");
            }
            ctx.restore();

            //bitblt offscreen canvas on main canvas:            
            // g_menuBuilderCanvas.getContext('2d').drawImage(g_offscreenCanvas, 0, 0);
            if(g_menuImage !== null) {
                g_menuBuilderCanvas.getContext('2d').drawImage(g_offscreenCanvas, 0, 0, g_menuImage.width, g_menuImage.height, 0, 0, g_offscreenCanvas.width, g_offscreenCanvas.height);
            } else {
                g_menuBuilderCanvas.getContext('2d').drawImage(g_offscreenCanvas, 0, 0);
            }

            // drawCursorLabels = (g_config.drawCursorLabels && g_menuBuilderCanvas !== null) && (g_mouseX > 0  && g_mouseY > 0);
            // if(drawCursorLabels) {
            //     if(words.length > 0) {
            //         drawLabel(g_menuBuilderCanvas, `(${parseInt(g_mouseX)},${parseInt(g_mouseY)}) ${words.join(" ")}`, g_mouseX, g_mouseY-22, 0, 22, "#000000ff", "#000000ff", "#ffffffff");
            //     } else {
            //         drawLabel(g_menuBuilderCanvas, `(${parseInt(g_mouseX)},${parseInt(g_mouseY)})`, g_mouseX, g_mouseY-22, 0, 22, "#000000ff", "#000000ff", "#ffffffff");
            //     }
            // }

            
        }



    </script>

    <div id="main" style="overflow:auto; position:fixed; left:0; top: 0; width:100%; height:100%; transform: scale(1, 1); transform-origin: top left;">
        <canvas id="menuBuilder"style="position:fixed; left:0; top: 0; width:100%; height:100%; transform: scale(1, 1); transform-origin: top left;"></canvas>
    </div>
   
    
    </body>
</html>
